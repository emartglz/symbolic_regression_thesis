\chapter{Propuesta de solución}\label{chapter:SolutionProposal}

En la sección anterior definimos los términos necesarios para entender el problema que consiste en:

Dado un conjunto de puntos de la forma $<ti,yi>$ encontrar un sistema de ecuaciones diferenciales que mejor describa los datos (en el sentido de los mínimos cuadrados).

En esta sección se tratarán varios elementos: regresión simbólica y de algoritmos genéticos.  Para usar un algoritmo genético es necesario definir cuáles son las posibles soluciones y para esas soluciones definir en qué consiste el cruzamiento, la mutación y cómo se puede saber cuán buena es una solución dada.

\section{Regresión simbólica}

La regresión simbólica que es un tipo de regresión que busca dentro de un espacio de expresiones matemáticas el modelo que mejor se ajuste a un conjunto de datos dados. En esta ningún modelo en particular es utilizado en el comienzo, en su lugar se generan expresiones que se forman de manera aleatoria combinando operaciones matemáticas, funciones analíticas, constantes y variables. Normalmente la regresión simbólica para funciones matemáticas es atacado con una variedad de métodos, uno de ellos es la recombinación de ecuaciones usando algoritmos evolutivos y uno de estos puede ser un algoritmo genético.

Al no requerir una especificación a priori de un modelo, la regresión simbólica no se ve afectada por el sesgo humano o las brechas desconocidas en el conocimiento del dominio. Intenta descubrir las relaciones intrínsecas del conjunto de datos, al permitir que los patrones en los propios datos revelen los modelos apropiados, en lugar de imponer una estructura de modelo que se considere matemáticamente manejable desde una perspectiva humana. La función de ajuste que impulsa la evolución de los modelos tiene en cuenta no solo las métricas de error (para garantizar que los modelos predigan los datos con precisión), sino también medidas especiales de complejidad, lo que garantiza que los modelos resultantes revelen la estructura subyacente de los datos en un manera que sea comprensible desde una perspectiva humana. Esto facilita el razonamiento y favorece las probabilidades de obtener información sobre el sistema de generación de datos.

Se ha demostrado que la regresión simbólica es un problema NP-difícil, en el sentido de que no siempre se puede encontrar la mejor expresión matemática posible para ajustarse a un conjunto de datos dado en tiempo polinomial.

\section{Algoritmos genéticos}

En ciencias de la computación un algoritmo genético es una metaheurística inspirada en el proceso natural de selección. Estos usualmente son utilizados para generar soluciones de alta calidad en problemas de optimización y búsqueda haciendo uso de los conocimientos de la biología, utilizando las acciones de mutación, cruzamiento y selección para modificar una población de individuos con el objetivo de obtener la solución deseada.

Para usar un algoritmo genético es necesario definir varios elementos:

- Cuáles son las posibles soluciones
- Cómo aplicar un operador de cruzamiento
- Cómo aplicar un operador de mutación
- Cómo determinar cuán buena es una solución
- Cómo determinar qué soluciones pasan a las próximas generaciones

Nuestro problema consiste en determinar el sistema de ecuaciones diferenciales que mejor se ajuste a un conjunto de datos y que sean lineales en los parámetros.

Con esto en mente, nuestras soluciones serían los posibles sistemas de ecuaciones lineales que cumplan con esas características. Por eso, en las próximas secciones vamos a describir: cómo representar las soluciones, cómo hacer cruzamientos y mutaciones, y cómo determinar cuán buena es una solución.

\section{Cómo representar una solución}

Como queremos resolver el problema de regresión simbólica en EDOs lineales en los parámetros, eso significa que estamos buscando una ecuación diferencial (lineal en los parámetros) que mejor ajuste los datos. Para ello, lo primero es decidir cómo representar los posibles sistemas.

Una vez que tengamos los datos $<ti, yi>$, tenemos algunas informaciones relevantes. Por ejemplo, si cada elemento de los datos es de la forma

$$(ti, y1i, y2i, y3i)$$

Entonces tenemos la certeza de que el sistema tiene tres ecuaciones, y que estamos buscando una expresión de la forma:

$$y1’ = f1(t, y1, y2, y3)$$
$$y2’ = f2(t, y1, y2, y3)$$
$$y3’ = f3(t, y1, y2, y3)$$

Ahora solo nos faltaría determinar cómo representar $f1$, $f2$ y $f3$.

Pero, a partir de los datos podemos decir que nuestras soluciones candidatas serían una lista de tres elementos, donde en la posición $i$ está codificada la función $fi(t,y1,y2,y3)$.

Por ejemplo, en el sistema SIR:

$S’ = - a*I*S$
$I’ = a*I*S - b*I $
$R’ = b*I$

La lista estaría formada por

$[-a*I*S, a*I*S - b*I, b*I]$

La pregunta es entonces cómo codificar cada uno de los elementos de la función.

Se sabe que una expresión aritmética (como cada una de las funciones) se puede representar mediante un árbol, donde los nodos interiores son operadores y las hojas son variables.  Esa pudiera ser una forma de representar cada uno de los elementos: en cada posición de la lista tendríamos un árbol que representa a la parte derecha de la ecuación diferencial.

Sin embargo, no es la mejor opción posible, porque aquí nos interesan sistemas de ecuaciones diferenciales que sean lineales con respecto a los parámetros.

Eso quiere decir que cada una de las funciones $fi$ son de la forma:

$$fi (t, y1, y2, y3) = a1 * g1(t, y1, y2, y3) + a2 * g1(t, y1, y2, y3) + … + ak * gk(t, y1, y2, y3)$$

donde cada una de las funciones $gi(t,y1,y2,y3)$ son funciones que no dependen de los parámetros.

Como se había planteado, en el caso del sistema SIR se tiene que:

$$f_S (t,S,I,R) = a1 * g_s1 (t,S,I,R)$$

donde

$$g_s1(t,S,I,R) = -I*S$$

$$f_I (t,S,I,R) = b1 * g_I1 (t,S,I,R) + b2 * g_I2 (t,S,I,R)$$

donde:

$$g_I1(t,S,I,R) = I*S$$

y
$$g_I2(t,S,I,R) = -I$$

$$f_R (t,S,I,R) = b1 * g_R1 (t,S,I,R)$$

donde:

$$g_R1(t,S,I,R) = I.$$

Como cada una de las las partes derechas de la ecuación diferencial son una suma de funciones, cada una de ellas se puede representar como un diccionario con una operación especial suma, que contiene una lista, donde en la posición i de la lista estaría una operación especial de multiplicación que contendríá como hijos al parámetro ai y la función que acompaña al parámetro ai en la suma de parámetros y funciones. Estas funciones igual se pueden representar como un árbol.

\section{Determinar costo de un sistema}

Se define el costo de una solución como la sumatoria de la diferencia al cuadrado de los datos evaluados en el sistema analizado con los datos objtivos. Está claro que esta sumatoria mientras más pequeña sea es mejor, dado que si es 0 es que hemos encontrado un sistema que ajusta perfectamente a los datos presentes. Resaltar que a esta sumatoria se le agrega un factor de peso que este aumenta con respecto al tamaño del sistema obtenido garantizando que el sistema tienda a ser lo más pequeño posible.

El sistema presenta parámetros en cada uno de los términos de las ecuaciones, Estos valores pueden ser ajustados para mejorar el costo en dependencia del sistema, en vez de solo colocar números aleatorios. Para esto se puede crear por cada ecuación del sistema, un sistema de ecuaciones de la forma Ax=B en el que el vector de incógnitas x sean los parámetros, A sean las expresiones que acompañan a cada parámetro evaluadas en el datos analizados, y B sea el dato objetivo.

Por ejemplo, la segunda ecuación del sistema SIR es:

$$f_I (t,S,I,R) = b1 * g_I1 (t,S,I,R) + b2 * g_I2 (t,S,I,R)$$

donde:

$$g_I1(t,S,I,R) = I*S$$

y

$$g_I2(t,S,I,R) = -I$$

y supongamos que tenemos de entrada los datos

$$f_I(0, 1, 2, 3) = 4$$
$$f_I(5, 6, 7, 8) = 9$$

entonces se puede encontrar los valores de b1 y b2 que mejor ajusten esa ecuación con los datos planteados formando el sistema de ecuaciones

$$b1 * g_I1(0, 1, 2, 3) + b2 * g_I2(0, 1, 2, 3) = 4$$
$$b1 * g_I1(5, 6, 7, 8) + b2 * g_I2(5, 6, 7, 8) = 9$$

$$b1 * (2 * 1) + b2 * (- 2) = 4$$
$$b1 * (7 * 6) + b2 * (- 7) = 9$$

$$b1 = -10/63$$
$$b2 = -47/21$$

De esta forma se encuentran los mejores parámetros para cada ecuación del sistema y se obtiene finalmente un sistema de ecuaciones con los parámetros lo mejor ajustados que pueden estar dado los datos de entrada.

\section{Mutación}

Una mutación es una operación que toma un individuo y genera uno nuevo a partir de este pero con características cambiadas, aunque sigue teniendo similaridad con el individuo inicial. Para esto se realiza un recorrido aleatorio de los distintos niveles antes mencionados escogiendo uno de estos para realizar una modificación en el, esta modificación es distinta en dependencia de su altura en la representación del sistema.

Regresando al ejemplo visto con anterioridad en el sistema:

$$S’ = 1 * I + 0.0 * S$$
$$I’ = 2 * (I + S)$$
$$R’ = 3.33 * S$$

Se puede realizar la mutación de eliminar el segundo sumando del primer término de la segunda ecuación. Esto resultaría en el sistema:

$$S’ = 1 * I + 0.0 * S$$
$$I’ = 2 * I$$
$$R’ = 3.33 * S$$

Esta mutación fue el resultado de la eliminación de un nodo en el árbol de la expresión de un término en una de las ecuaciones, existen muchas más, como cambiar la operación de un nodo, agregar una operación, agregar un término a una ecuación, eliminar un término de una ecuación.

\section{Cruzamiento}

Un cruzamiento es una operación que toma características de dos individuos de la población y retorna un nuevo individuo que posee caráterísticas de ambos padres. Para esto se decide primeramente que sitio se desea cruzar, cuando se plantea sitio se refiere a qué parte del sistema se desea cruzar, por ejemplo se podría cruzar a nivel de la lista de las ecuaciones, o a nivel de las expresiones que se encuentran en uno de los términos de una de las ecuaciones del sistema. Es importante que se tenga en cuenta esta organización de los individuos por niveles. En donde recordemos, la raiz es una lista de ecuaciones, el segundo nivel sería la sumatoria de términos y el tercer nivel sería las expresiones pertenecientes a cada término.

En dependencia del sitio que se desee cruzar, se toma un nodo correspondiente a cada padre y se intercambian de posición. En el caso de la implementación presente se retorna el resultado de la sustitución del nodo seleccionado en el padre 2, dentro del padre 1. Resaltar que la elección del sitio a cruzar se realiza de manera aleatoria. Si se decide cruzar en algún nivel distinto de la raiz, se toman nodos de la misma ecuación del sistema de ambos padres.

Por ejemplo, podemos tomar los sistemas:

$$S’ = 1 * I + 0.0 * S$$
$$I’ = 2 * I$$
$$R’ = 3.33 * S$$

y

$$S’ = 5 * R$$
$$I’ = 3 * (R * I) + 4 * S$$
$$R’ = 7 * I$$

e intercambiar las ecuaciones correspondientes a I’ resultando:

$$S’ = 1 * I + 0.0 * S$$
$$I’ = 3 * (R * I) + 4 * S$$
$$R’ = 3.33 * S$$

\section{Determinación de las soluciones que pasan a la siguiente generación}

Dada una población en una generación, se toma un conjunto de individuos de esta y se mutan, y se toma otro subconjunto de individuos y se cruzan entre ellos. Todos estos individuos son seleccionados de forma aleatoria. Este nuevo subconjunto formado por la población inicial de la generación, los individuos resultantes de la mutación y los individuos resultantes de los cruzamientos tienen que ser filtrados para tomar una cantidad igual a la población inicial presente en la generación con el objetivo de poder repetir este proceso múltiples veces para poder realizar numerosas generaciones. Para poder filtrar este subconjunto se toman los individuos que mejor puntuaciones obtuvieron con respecto a los datos iniciales, o sea, se toman los sistemas que mejor ajustan a los datos.
