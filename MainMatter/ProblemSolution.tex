\chapter{Propuesta de solución}\label{chapter:solution_proposal}

En este capitulo se plantea una forma de obtener, a partir de un conjunto de datos, un sistema de ecuaciones diferenciales lineales en los parámetros que se ajuste a estos datos. Este sistema se obtiene mediante el uso de la regresión simbólica utilizando un algoritmo genético.

La primera sección del capítulo detalla como se puede representar un sistema de EDOs lineales en los parámetros mediante un árbol computacional. En la sección siguiente se explica la función de ajuste que se tiene en cuenta en la regresión simbólica planteada. En las secciones \ref{section:mutation}, \ref{section:xcross} y \ref{section:selection} se detallan las operaciones necesarias para la aplicación de un algoritmo genético: la mutación, el cruzamiento y la selección respectivamente.

\section{Cómo representar una solución}

Teniendo un conjunto de datos de la forma $\{(t_i, y_i)\}$, se puede conocer la forma que debe tener el modelo que se intenta encontrar con el algoritmo. Por ejemplo, si cada elemento de los datos es de la forma:

$$(t_i, y_{1_i}, y_{2_i}, y_{3_i}),$$

entonces se tiene la certeza de que el sistema de ecuaciones diferenciales que se desea tiene tres ecuaciones, y que los sistemas de ecuaciones en el espacio de búsqueda del método deben tener la forma:

$$y_1' = f_1(t, y_1, y_2, y_3)$$
$$y_2' = f_2(t, y_1, y_2, y_3)$$
$$y_3' = f_3(t, y_1, y_2, y_3)$$

Conociendo la cantidad de ecuaciones presentes en el sistema se puede decir que las soluciones candidatas a solución son una lista de $n$ elementos, siendo $n$ la cantidad de ecuaciones. La posición $i$ de esta lista representa la función $f_i(t,y_1,y_2,y_3)$.

Por ejemplo, en el modelo poblacional SIR:

\begin{align*}
    S' & = - a*I*S     \\
    I' & = a*I*S - b*I \\
    R' & = b*I,
\end{align*}

se puede decir que:

\begin{align*}
    S'(t) & = f_S(t, S, I, R)  \\
    I'(t) & = f_I(t, S, I, R)  \\
    R'(t) & = f_R(t, S, I, R).
\end{align*}

Entonces se puede representar con la lista:

$$[f_S(t, S, I, R), f_I(t, S, I, R), f_R(t, S, I, R)]$$
$$= [-a*I*S, a*I*S - b*I, b*I].$$

Una expresión aritmética (como cada una de las funciones) se puede representar mediante un árbol, donde los nodos interiores son operadores y las hojas son variables. Entonces se puede representar en cada posición de la lista el árbol computacional que describe la parte de la derecha de la ecuación diferencial correspondiente a esa posición.

Sin embargo con esta representación descrita por Koza \cite{zelinka2005analytic}, no se plantea de forma explícita la linealidad de las ecuaciones diferenciales con respecto a los parámetros. Por lo que no resulta útil ya que en el algoritmo no deben aparecer modelos que incumplan esta propiedad de linealidad. Para que esta forma de representar las funciones en forma de árboles computacionales impida la no linealidad con respecto a los parámetros se modifica la estructura del árbol de la siguiente manera.

Como la parte derecha de una ecuación diferencial lineal con respecto a los parámetros es una sumatoria de multiplicaciones de parámetros con funciones que no dependen de parámetros

$$\frac{dX_i}{dt} = \sum_{i=1}^{n} a_i * f_i(t, y(t)),$$

entonces cada una de las partes derechas de las ecuaciones diferenciales se representan con un árbol en el que la raiz es un nodo con una operación especial de suma, que puede tener cualquier cantidad de sumandos (o de hijos).

\begin{center}
    \begin{tikzpicture}[
            roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
            roundnode_transparent/.style={circle, very thick, minimum size=5mm}
        ]
        % Nodes
        \node[roundnode]        (plus)                            {$+$};
        \node[roundnode]        (term_1)     [below left=of plus]        {$a_1 * f_1(t, y(t))$};
        \node[roundnode_transparent]        (term_dots)     [below =of plus]        {$\dots$};
        \node[roundnode]        (term_n)     [below right=of plus]        {$a_n * f_n(t, y(t))$};


        %Lines
        \draw [->] (plus.south) -- (term_1.north);
        % \draw [->] (plus.south) -- (term_dots.north);
        \draw [->] (plus.south) -- (term_n.north);
    \end{tikzpicture}
\end{center}


Cada uno de estos hijos es un subárbol que representa la multiplicación de un parámetro con una función que no depende de parámetros. Estos subárboles poseen como raiz un nodo con una operación de multiplicación y dos nodos hijos. El primero de ellos sería un nodo hoja representando el parámetro. El segundo de ellos sería un nodo que representa el subárbol computacional correspondiente a la función utilizando la misma representación planteada por Koza \cite{zelinka2005analytic} pero con la peculiaridad de que sus hojas solo podrán almacenar variables, no parámetros.

\begin{center}
    \begin{tikzpicture}[
            roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
            squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=7mm}
        ]
        % Nodes
        \node[roundnode]        (star)                            {$*$};
        \node[squarednode]        (term_1)     [below left=of star]        {$a_i$};
        \node[roundnode]        (term_n)     [below right=of star]        {$f_i(t, y(t))$};


        %Lines
        \draw [->] (star.south) -- (term_1.north);
        \draw [->] (star.south) -- (term_n.north);
    \end{tikzpicture}
\end{center}


Cada ecuación diferencial sería un hijo de un nodo que representa al sistema de ecuaciones diferenciales. Como ejemplo se puede utilizar el modelo poblacional SIR que es lineal con respecto a sus parámetros, por lo que su representación con la estructura propuesta sería:

\begin{center}
    \begin{tikzpicture}[
            roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
            squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm}
        ]
        % Nodes
        \node[roundnode]        (system)                            {$SYSTEM$};

        \node[roundnode]        (plus_S)     [below left=of system]        {$+$};
        \node[roundnode]        (star_S_1)    [below left=of plus_S]    {$*$};
        \node[squarednode]      (alpha_star_S_1)      [below left=of star_S_1]    {$a$};
        \node[roundnode]        (neg_star_S_1)    [below=of star_S_1]    {$-$};
        \node[roundnode]        (star_S_2)    [below=of neg_star_S_1]    {$*$};
        \node[squarednode]      (S_star_S)       [below left=of star_S_2]   {$S$};
        \node[squarednode]      (I_star_S)      [below=of star_S_2]   {$I$};

        \node[roundnode]        (plus_I)     [below=of system]        {$+$};
        \node[roundnode]        (star_I_1)    [below left=of plus_I]    {$*$};
        \node[squarednode]      (alpha_star_I_1)      [below left=1cm and 0.5cm of star_I_1]    {$a$};
        \node[roundnode]        (star_I_2)    [below=of star_I_1]    {$*$};
        \node[squarednode]      (S_star_I)       [below left=1cm and 0.5cm of star_I_2]   {$S$};
        \node[squarednode]      (I_star_I_1)      [below=of star_I_2]   {$I$};

        \node[roundnode]        (star_I_3)    [below right=of plus_I]    {$*$};
        \node[squarednode]      (beta_star_I_1)      [below=of star_I_3]    {$b$};
        \node[roundnode]        (neg_star_I_1)    [below right=1cm and 0.5cm of star_I_3]    {$-$};
        \node[squarednode]      (I_star_I_2)      [below=of neg_star_I_1]   {$I$};

        \node[roundnode]        (plus_R)     [below right=of system]        {$+$};
        \node[roundnode]        (star_R_1)    [below right=of plus_R]    {$*$};
        \node[squarednode]      (beta_star_R_1)      [below=of star_R_1]    {$b$};
        \node[squarednode]      (I_star_R)      [below right=of star_R_1]   {$I$};

        %Lines
        \draw [->] (system.south) -- (plus_S.north);
        \draw[->] (system.south) -- (plus_I.north);
        \draw[->] (system.south) -- (plus_R.north);

        \draw[->] (plus_S.south) -- (star_S_1.north);
        \draw[->] (star_S_1.south) -- (alpha_star_S_1.north);
        \draw[->] (star_S_1.south) -- (neg_star_S_1.north);
        \draw[->] (neg_star_S_1.south) -- (star_S_2.north);
        \draw[->] (star_S_2.south) -- (S_star_S.north);
        \draw[->] (star_S_2.south) -- (I_star_S.north);

        \draw[->] (plus_I.south) -- (star_I_1.north);
        \draw[->] (plus_I.south) -- (star_I_3.north);
        \draw[->] (star_I_1.south) -- (alpha_star_I_1.north);
        \draw[->] (star_I_1.south) -- (star_I_2.north);
        \draw[->] (star_I_2.south) -- (S_star_I.north);
        \draw[->] (star_I_2.south) -- (I_star_I_1.north);

        \draw[->] (star_I_3.south) -- (beta_star_I_1.north);
        \draw[->] (star_I_3.south) -- (neg_star_I_1.north);
        \draw[->] (neg_star_I_1.south) -- (I_star_I_2.north);

        \draw[->] (plus_R.south) -- (star_R_1.north);
        \draw[->] (star_R_1.south) -- (beta_star_R_1.north);
        \draw[->] (star_R_1.south) -- (I_star_R.north);
    \end{tikzpicture}
\end{center}

Con esta nueva representación se pueden expresar todos los sistemas de ecuaciones diferenciales lineales en los parámetros. Por esta razón es la estructura que se utiliza para la representación de los modelos generados por el algoritmo de regresión simbólica detallado en este capítulo.

En un método de regresión simbólica es necesario una función de ajuste que permita conocer que tan cercano son los datos evaluados en el modelo obtenido con respecto a los datos originales, para esto se define el costo de un sistema que se explica en la sección siguiente.

\section{Determinar costo de una solución}\label{section:solution_cost}

Sea $n$ la cantidad de ecuaciones en el sistema y $m$ la cantidad de datos, se define el costo de un sistema de ecuaciones diferenciales $f$ como:

$$C = \frac{\sum_{i=1}^n\frac{\sum_{j=1}^{m}(y_{i_j} - f_i(x_j))^2}{m}}{n},$$

con:

$$f_i(x_j) = \sum_{k=1}^{p_i} a_{i_k} * g_{i_k}(x_j),$$

donde $f_1, f_2, \dots, f_n$ son las partes derechas de las ecuaciones del sistema, $p_i$ indica la cantidad de parámetros presentes en la ecuación $i$ del sistema.

Mientras más cercano a 0 es el valor del costo, más se describe el fenómeno representado por los datos ya que si es 0 significa que se ha encontrado un sistema que ajusta perfectamente los puntos.

Al valor de $C$ se le agrega un factor de peso $P$, el cual es directamente propociornal a la cantidad de términos que posean las ecuaciones de la solución:

$$P = \begin{cases}
        Constant * node\_count(f), & \text{si } node\_count(f) \geq MAX\_NODES \\
        0,                         & \text{de otra forma}
    \end{cases},$$

donde $node\_count(f)$ es la cantidad de nodos presentes en la representación en forma de árbol computacional del sistema $f$. $Constant$ es una constante definida en la implementación, en los experimentos realizados en el capítulo \ref{chapter:results} se utiliza un valor de 9999.

El parámetro $MAX\_NODES$ se define junto con los demás parámetros del algoritmo genético. Este factor de peso garantiza que si dos ecuaciones son capaces de generar los mismos puntos, la ecuación con menos términos tenga una mejor evaluacion en la función objetivo.

Para que la sumatoria $\sum_{j=1}^{m}(y_{i_j} - f_i(x_j)) ^ 2$ sea la menor posible se debe minimizar la diferencia $y_{i_j} - f_i(x_j)$. Para esto se ajustan los parámetros $a_{i_k}$ presentes en cada una de las ecuaciones $f_i$. Por esta razón se crea, por cada ecuación del sistema, un sistema de ecuaciones de la forma $A_i * x_i = B_i$ donde:

\begin{align*}
    A_i & = \begin{pmatrix}
        g_{i_1}(x_1) & g_{i_2}(x_1) & \dots  & g_{i_k}(x_1) \\
        g_{i_1}(x_2) & g_{i_2}(x_2) &        & g_{i_k}(x_2) \\
        \vdots       & \vdots       & \ddots & \vdots       \\
        g_{i_1}(x_m) & g_{i_2}(x_m) &        & g_{i_k}(x_m)
    \end{pmatrix}
    \qquad
    x_i = \begin{bmatrix}
        a_{i_1} \\
        a_{i_2} \\
        \vdots  \\
        a_{i_k}
    \end{bmatrix}
    \qquad
    B_i = \begin{bmatrix}
        y_{i_1} \\
        y_{i_2} \\
        \vdots  \\
        y_{i_m}
    \end{bmatrix}.
\end{align*}

Este sistema se resuelve utilizando el método de ajuste mínimo cuadrático de datos, explicado en el capítulo \ref{chapter:preliminaries}.

Por ejemplo, la segunda ecuación del modelo poblacional SIR es:

$$f_I (t,S,I,R) = a_{I_1} * g_{I_1}(t,S,I,R) + a_{I_2} * g_{I_2}(t,S,I,R),$$

donde:

$$g_{I_1}(t,S,I,R) = I*S$$

y

$$g_{I_2}(t,S,I,R) = -I.$$

Suponiendo que tenemos de entrada los puntos:

$$f_I(1, 4, 9, 6) = 5 $$
$$f_I(2, 6, 8, 2) = 4 $$
$$f_I(3, 3, 6, 8) = 10$$
$$f_I(4, 5, 9, 8) = 1 $$
$$f_I(5, 6, 3, 10) =7 $$
$$f_I(6, 8, 5, 7) = 6 $$

entonces se puede encontrar los valores de $a_1$ y $a_2$ que mejor ajusten esta ecuación con los puntos vistos anteriormente formando el sistema de ecuaciones:

\begin{align*}
    A_I & = \begin{pmatrix}
        36 & -9 \\
        48 & -8 \\
        18 & -6 \\
        45 & -9 \\
        18 & -3 \\
        40 & -5
    \end{pmatrix}
    \qquad
    x_I = \begin{bmatrix}
        a_{I_1} \\
        a_{I_2}
    \end{bmatrix}
    \qquad
    B_I = \begin{bmatrix}
        5  \\
        4  \\
        10 \\
        1  \\
        7  \\
        6
    \end{bmatrix}.
\end{align*}

Al resolver este sistema de ecuaciones sobredeterminados se obtienen los parámetros $a_{I_1}$ = -0.03570806 y $a_{I_2}$ = -0.84347764. Este método de ajuste mínimo cuadrado de datos se aplica para ajustar los parámetros de cada una de las ecuaciones del sistema.

Como se plantea al inicio del capítulo, se utiliza el método de regresión simbólica mediante el uso de un algoritmo genético para encontrar el sistema que mejor ajuste un conjunto de puntos. Para usar el algoritmo genético se necesitan definir las operaciones de mutación, cruzamiento y selección. En la siguiente sección se define la primera de estas operaciones.

\section{Mutación}\label{section:mutation}

La operación de mutación selecciona el subárbol representante de una de las ecuaciones en el sistema y luego se escoge una de las siguientes modificaciones:

\begin{itemize}
    \item Eliminar un término (sumando de la ecuación) de la ecuación. Si se toman los sumandos de la ecuación como una lista de términos, este criterio consiste en seleccionar un término y eliminarlo.

          Por ejemplo si se tiene la ecuación

          $$a_1 * y_1 + a_2 * -(y_1 * y_2),$$

          la lista de términos correspondientes sería:

          $$[a_1*y_1, a_2 * -(y_1 * y_2)].$$

          Si se selecciona eliminar el segundo término, la ecuación resultante sería:

          $$a_1 * y_1.$$

          Este ejemplo se puede expresar en forma de árbol computacional de la siguiente manera:

          \begin{center}
              \begin{adjustbox}{width=0.35\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                             {$+$};
                      \node[roundnode]           (star1)   [below left=of plus]    {$*$};
                      \node[squarednode]         (a_1)   [below left=of star1]    {$a_1$};
                      \node[squarednode]         (y_1)     [below=of star1]         {$y_1$};
                      \node[roundnode_dashed]           (star2)   [below right=of plus]   {$*$};
                      \node[squarednode]         (a_2)    [below left=of star2]    {$a_2$};
                      \node[roundnode]           (neg)     [below=of star2]         {$-$};
                      \node[roundnode]           (star3)   [below=of neg]         {$*$};
                      \node[squarednode]         (y_1_2)   [below=of star3]   {$y_1$};
                      \node[squarednode]         (y_2)     [below right=of star3]   {$y_2$};

                      %Lines
                      \draw[->] (plus.south) -- (star1.north);
                      \draw[->] (plus.south) -- (star2.north);
                      \draw[->] (star1.south) -- (a_1.north);
                      \draw[->] (star1.south) -- (y_1.north);
                      \draw[->] (star2.south) -- (a_2.north);
                      \draw[->] (star2.south) -- (neg.north);
                      \draw[->] (neg.south) -- (star3.north);
                      \draw[->] (star3.south) -- (y_1_2.north);
                      \draw[->] (star3.south) -- (y_2.north);
                  \end{tikzpicture}%
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.20\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                             {$+$};
                      \node[roundnode]           (star1)   [below =of plus]    {$*$};
                      \node[squarednode]         (a_1)   [below left=of star1]    {$a_1$};
                      \node[squarednode]         (y_1)     [below right=of star1]         {$y_1$};

                      %Lines
                      \draw[->] (plus.south) -- (star1.north);
                      \draw[->] (star1.south) -- (a_1.north);
                      \draw[->] (star1.south) -- (y_1.north);
                  \end{tikzpicture}%
              \end{adjustbox}
          \end{center}

    \item Añadir un término a la ecuación. Si se toman los sumandos de la ecuación como una lista de términos, este criterio consiste en crear un término y añadirlo.

          Por ejemplo si se tiene la ecuación

          $$a_1 * y_1,$$

          la lista de términos correspondientes sería:

          $$[a_1*y_1].$$

          Si se selecciona añadir como segundo sumando el término $a_2 * y_2$, la ecuación resultante sería:

          $$a_1 * y_1 + a_2 * y_2.$$

          Este ejemplo se puede expresar en forma de árbol computacional de la siguiente manera:

          \begin{center}
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                             {$+$};
                      \node[roundnode]           (star1)   [below =of plus]    {$*$};
                      \node[squarednode]         (a_1)   [below left=of star1]    {$a_1$};
                      \node[squarednode]         (y_1)     [below right=of star1]         {$y_1$};

                      %Lines
                      \draw[->] (plus.south) -- (star1.north);
                      \draw[->] (star1.south) -- (a_1.north);
                      \draw[->] (star1.south) -- (y_1.north);
                  \end{tikzpicture}%
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.35\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                             {$+$};
                      \node[roundnode]           (star1)   [below left=of plus]    {$*$};
                      \node[squarednode]         (a_1)   [below left=of star1]    {$a_1$};
                      \node[squarednode]         (y_1)     [below=of star1]         {$y_1$};
                      \node[roundnode_dashed]           (star2)   [below right=of plus]   {$*$};
                      \node[squarednode]         (a_2)    [below=of star2]    {$a_2$};
                      \node[squarednode]           (y_2)     [below right=of star2]         {$y_2$};

                      %Lines
                      \draw[->] (plus.south) -- (star1.north);
                      \draw[->] (plus.south) -- (star2.north);
                      \draw[->] (star1.south) -- (a_1.north);
                      \draw[->] (star1.south) -- (y_1.north);
                      \draw[->] (star2.south) -- (a_2.north);
                      \draw[->] (star2.south) -- (y_2.north);
                  \end{tikzpicture}%
              \end{adjustbox}
          \end{center}

    \item Mutar un término de la ecuación. Si se toman los sumandos de la ecuación como una lista de términos, este criterio consiste en seleccionar un término y dentro de su representación en forma de árbol computacional tomar un nodo y aplicarle una de las sisguientes modificaciones.
\end{itemize}

Si el nodo representa una operación:

\begin{itemize}
    \item Cambia la operación en el nodo por uno que posea la misma cantidad de parámetros del operador:

          Por ejempo si se tiene el término $y_1 + (y_2 - y_3)$ se puede sustituir la resta por una suma resultando $y_1 + (y_2 + y_3)$. Expresado en forma de árbol computacional sería:

          \begin{center}
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %               %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode_dashed]      (sub)     [below right=of plus]   {$-$};
                      \node[squarednode]    (y_2)     [below left=of sub]     {$y_2$};
                      \node[squarednode]    (y_3)     [below right=of sub]    {$y_3$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (y_3.north);
                  \end{tikzpicture}%
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode_dashed]      (plus_2)     [below right=of plus]   {$+$};
                      \node[squarednode]    (y_2)     [below left=of plus_2]     {$y_2$};
                      \node[squarednode]    (y_3)     [below right=of plus_2]    {$y_3$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (plus_2.north);
                      \draw[->] (plus_2.south) -- (y_2.north);
                      \draw[->] (plus_2.south) -- (y_3.north);
                  \end{tikzpicture}%
              \end{adjustbox}
          \end{center}

    \item Elimina el nodo, colocando en su lugar su primer hijo.

          Por ejempo si se tiene el término $y_1 + (y_2 - y_3)$ se puede sustituir la resta por el minuendo resultando $y_1 + y_2$. Expresado en forma de árbol computacional sería:

          \begin{center}
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode_dashed]      (sub)     [below right=of plus]   {$-$};
                      \node[squarednode]    (y_2)     [below left=of sub]     {$y_2$};
                      \node[squarednode]    (y_3)     [below right=of sub]    {$y_3$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (y_3.north);
                  \end{tikzpicture}%
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[squarednode]    (y_2)     [below right=of plus]     {$y_2$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (y_2.north);
                  \end{tikzpicture}%
              \end{adjustbox}
          \end{center}

    \item Cambia el nodo por uno nuevo representando una operación aletoria colocando como hijos nuevos árboles de expresiones aleatorias y colocando como último hijo el nodo original seleccionado.

          Por ejempo si se tiene el término $y_1 + (y_2 - y_3)$ se puede sustituir la resta por una multiplicación colocando como segundo factor la misma resta resultando $y_1 + y_4 * (y_2 - y_3)$. Expresado en forma de árbol computacional sería:

          \begin{center}
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode_dashed]      (sub)     [below right=of plus]   {$-$};
                      \node[squarednode]    (y_2)     [below left=of sub]     {$y_2$};
                      \node[squarednode]    (y_3)     [below right=of sub]    {$y_3$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (y_3.north);
                  \end{tikzpicture}%
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode]    (star)  [below right=of plus]   {$*$};
                      \node[squarednode]  (y_4)   [below left=of star]        {$y_4$};
                      \node[roundnode_dashed]      (sub)     [below right=of star]   {$-$};
                      \node[squarednode]    (y_2)     [below left=of sub]     {$y_2$};
                      \node[squarednode]    (y_3)     [below right=of sub]    {$y_3$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (star.north);
                      \draw[->] (star.south) -- (y_4.north);
                      \draw[->] (star.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (y_3.north);
                  \end{tikzpicture}%
              \end{adjustbox}
          \end{center}

\end{itemize}

Si el nodo representa una variable:

\begin{itemize}
    \item Cambiar la variable por otra permitida dentro de la ecuación.

          Por ejempo si se tiene el término $y_1 + (y_2 - y_3)$ se puede sustituir la sustraendo por $y_3$ resultando $y_1 + (y_2 - y_1)$. Expresado en forma de árbol computacional sería:

          \begin{center}
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          squarednode_dashed/.style={rectangle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode]      (sub)     [below right=of plus]   {$-$};
                      \node[squarednode]    (y_2)     [below left=of sub]     {$y_2$};
                      \node[squarednode_dashed]    (y_3)     [below right=of sub]    {$y_3$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (y_3.north);
                  \end{tikzpicture}%
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          squarednode_dashed/.style={rectangle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode]      (sub)     [below right=of plus]   {$-$};
                      \node[squarednode]    (y_2)     [below left=of sub]     {$y_2$};
                      \node[squarednode_dashed]    (y_1_2)     [below right=of sub]    {$y_1$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (y_1_2.north);
                  \end{tikzpicture}%
              \end{adjustbox}
          \end{center}

    \item Cambiar la variable por un nodo que represente una operación  aleatoria donde el primer hijo es la variable seleccionada

          Por ejempo si se tiene el término $y_1 + (y_2 - y_3)$ se puede sustituir el sustraendo por una multiplicación donde el primer factor sea el mismo sustraendo resultando $y_1 + (y_2 - y_3 * y_2)$. Expresado en forma de árbol computacional sería:

          \begin{center}
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          squarednode_dashed/.style={rectangle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode]      (sub)     [below right=of plus]   {$-$};
                      \node[squarednode]    (y_2)     [below left=of sub]     {$y_2$};
                      \node[squarednode_dashed]    (y_3)     [below right=of sub]    {$y_3$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (y_3.north);
                  \end{tikzpicture}%
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.25\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          squarednode_dashed/.style={rectangle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      %Nodes
                      \node[roundnode]      (plus)                            {$+$};
                      \node[squarednode]    (y_1)     [below left=of plus]    {$y_1$};
                      \node[roundnode]    (sub)  [below right=of plus]   {$-$};
                      \node[squarednode]  (y_2)   [below left=of sub]        {$y_2$};
                      \node[roundnode]      (star)     [below right=of sub]   {$*$};
                      \node[squarednode_dashed]    (y_3)     [below left=of star]    {$y_3$};
                      \node[squarednode]    (y_2_2)     [below right=of star]     {$y_2$};


                      %   %Lines
                      \draw[->] (plus.south) -- (y_1.north);
                      \draw[->] (plus.south) -- (sub.north);
                      \draw[->] (sub.south) -- (y_2.north);
                      \draw[->] (sub.south) -- (star.north);
                      \draw[->] (star.south) -- (y_3.north);
                      \draw[->] (star.south) -- (y_2_2.north);
                  \end{tikzpicture}%
              \end{adjustbox}
          \end{center}

\end{itemize}

Si se tiene el sistema

\begin{align*}
    S' & = - a_1 * S * I         \\
    I' & = a_2 * S * I - a_3 * I \\
    R' & = a_4 * I,
\end{align*}

que se representa en forma de árbol computacional como:

\begin{center}
    \begin{adjustbox}{width=0.5\textwidth, keepaspectratio}
        \begin{tikzpicture}[
                roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
            ]
            % Nodes
            \node[roundnode]        (system)                            {$SYSTEM$};

            \node[roundnode]        (plus_S)     [below left=of system]        {$+$};
            \node[roundnode]        (star_S_1)    [below left=of plus_S]    {$*$};
            \node[squarednode]      (alpha_star_S_1)      [below left=of star_S_1]    {$a_1$};
            \node[roundnode]        (neg_star_S_1)    [below=of star_S_1]    {$-$};
            \node[roundnode]        (star_S_2)    [below=of neg_star_S_1]    {$*$};
            \node[squarednode]      (S_star_S)       [below left=of star_S_2]   {$S$};
            \node[squarednode]      (I_star_S)      [below=of star_S_2]   {$I$};

            \node[roundnode]        (plus_I)     [below=of system]        {$+$};
            \node[roundnode]        (star_I_1)    [below left=of plus_I]    {$*$};
            \node[squarednode]      (alpha_star_I_1)      [below left=1cm and 0.5cm of star_I_1]    {$a_2$};
            \node[roundnode]        (star_I_2)    [below=of star_I_1]    {$*$};
            \node[squarednode]      (S_star_I)       [below left=1cm and 0.5cm of star_I_2]   {$S$};
            \node[squarednode]      (I_star_I_1)      [below=of star_I_2]   {$I$};

            \node[roundnode_dashed]        (star_I_3)    [below right=of plus_I]    {$*$};
            \node[squarednode]      (beta_star_I_1)      [below=of star_I_3]    {$a_3$};
            \node[roundnode]        (neg_star_I_1)    [below right=1cm and 0.5cm of star_I_3]    {$-$};
            \node[squarednode]      (I_star_I_2)      [below=of neg_star_I_1]   {$I$};

            \node[roundnode]        (plus_R)     [below right=of system]        {$+$};
            \node[roundnode]        (star_R_1)    [below right=of plus_R]    {$*$};
            \node[squarednode]      (beta_star_R_1)      [below=of star_R_1]    {$a_4$};
            \node[squarednode]      (I_star_R)      [below right=of star_R_1]   {$I$};

            %Lines
            \draw [->] (system.south) -- (plus_S.north);
            \draw[->] (system.south) -- (plus_I.north);
            \draw[->] (system.south) -- (plus_R.north);

            \draw[->] (plus_S.south) -- (star_S_1.north);
            \draw[->] (star_S_1.south) -- (alpha_star_S_1.north);
            \draw[->] (star_S_1.south) -- (neg_star_S_1.north);
            \draw[->] (neg_star_S_1.south) -- (star_S_2.north);
            \draw[->] (star_S_2.south) -- (S_star_S.north);
            \draw[->] (star_S_2.south) -- (I_star_S.north);

            \draw[->] (plus_I.south) -- (star_I_1.north);
            \draw[->] (plus_I.south) -- (star_I_3.north);
            \draw[->] (star_I_1.south) -- (alpha_star_I_1.north);
            \draw[->] (star_I_1.south) -- (star_I_2.north);
            \draw[->] (star_I_2.south) -- (S_star_I.north);
            \draw[->] (star_I_2.south) -- (I_star_I_1.north);

            \draw[->] (star_I_3.south) -- (beta_star_I_1.north);
            \draw[->] (star_I_3.south) -- (neg_star_I_1.north);
            \draw[->] (neg_star_I_1.south) -- (I_star_I_2.north);

            \draw[->] (plus_R.south) -- (star_R_1.north);
            \draw[->] (star_R_1.south) -- (beta_star_R_1.north);
            \draw[->] (star_R_1.south) -- (I_star_R.north);
        \end{tikzpicture}
    \end{adjustbox}
\end{center}

Se puede realizar la mutación de eliminar el segundo término de la segunda ecuación quedando como resultado el sistema

\begin{align*}
    S' & = - a_1 * S * I \\
    I' & = a_2 * S * I   \\
    R' & = a_4 * I,
\end{align*}

que visto en forma de árbol computacional es:

\begin{center}
    \begin{adjustbox}{width=0.5\textwidth, keepaspectratio}
        \begin{tikzpicture}[
                roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
            ]
            % Nodes
            \node[roundnode]        (system)                            {$SYSTEM$};

            \node[roundnode]        (plus_S)     [below left=of system]        {$+$};
            \node[roundnode]        (star_S_1)    [below left=of plus_S]    {$*$};
            \node[squarednode]      (alpha_star_S_1)      [below left=of star_S_1]    {$a_1$};
            \node[roundnode]        (neg_star_S_1)    [below=of star_S_1]    {$-$};
            \node[roundnode]        (star_S_2)    [below=of neg_star_S_1]    {$*$};
            \node[squarednode]      (S_star_S)       [below left=of star_S_2]   {$S$};
            \node[squarednode]      (I_star_S)      [below=of star_S_2]   {$I$};

            \node[roundnode]        (plus_I)     [below=of system]        {$+$};
            \node[roundnode]        (star_I_1)    [below=of plus_I]    {$*$};
            \node[squarednode]      (alpha_star_I_1)      [below left=of star_I_1]    {$a_2$};
            \node[roundnode]        (star_I_2)    [below right=of star_I_1]    {$*$};
            \node[squarednode]      (S_star_I)       [below left=of star_I_2]   {$S$};
            \node[squarednode]      (I_star_I_1)      [below=of star_I_2]   {$I$};

            \node[roundnode]        (plus_R)     [below right=of system]        {$+$};
            \node[roundnode]        (star_R_1)    [below right=of plus_R]    {$*$};
            \node[squarednode]      (beta_star_R_1)      [below=of star_R_1]    {$a_4$};
            \node[squarednode]      (I_star_R)      [below right=of star_R_1]   {$I$};

            %Lines
            \draw [->] (system.south) -- (plus_S.north);
            \draw[->] (system.south) -- (plus_I.north);
            \draw[->] (system.south) -- (plus_R.north);

            \draw[->] (plus_S.south) -- (star_S_1.north);
            \draw[->] (star_S_1.south) -- (alpha_star_S_1.north);
            \draw[->] (star_S_1.south) -- (neg_star_S_1.north);
            \draw[->] (neg_star_S_1.south) -- (star_S_2.north);
            \draw[->] (star_S_2.south) -- (S_star_S.north);
            \draw[->] (star_S_2.south) -- (I_star_S.north);

            \draw[->] (plus_I.south) -- (star_I_1.north);
            \draw[->] (star_I_1.south) -- (alpha_star_I_1.north);
            \draw[->] (star_I_1.south) -- (star_I_2.north);
            \draw[->] (star_I_2.south) -- (S_star_I.north);
            \draw[->] (star_I_2.south) -- (I_star_I_1.north);

            \draw[->] (plus_R.south) -- (star_R_1.north);
            \draw[->] (star_R_1.south) -- (beta_star_R_1.north);
            \draw[->] (star_R_1.south) -- (I_star_R.north);
        \end{tikzpicture}
    \end{adjustbox}
\end{center}

Otra de las operaciones que se deben definir con el fin de implementar un algoritmo genético es el cruzamiento, esta operación se específica en la siguiente sección.

\section{Cruzamiento}\label{section:xcross}

La operación de cruzamiento selecciona dos sistemas aleatorios dentro de la población de soluciones presentes en el algoritmo genético, se definen estos sistemas como A y B. Luego se selecciona un nodo aleatorio dentro del árbol A, impidiendo que la selección tome hojas que representen parámetros. En dependencia de la altura del nodo seleccionado se escoge un nodo en B siguiendo las siguientes reglas:

\begin{itemize}
    \item Si el nodo seleccionado en A es el representante de la i-ésima ecuación en el sistema, se escoge el nodo representante de la i-ésima ecuación en el sistema B:

          \begin{center}
              \begin{adjustbox}{width=0.4\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      % Nodes
                      \node[roundnode]        (system)                            {$A$};

                      \node[roundnode]        (plus_1)     [below left=of system]        {$+$};
                      \node[roundnode]        (star_1_1)    [below=of plus_1]    {$*$};
                      \node[squarednode]      (a_1)      [below left=of star_1_1]    {$a_1$};
                      \node[roundnode]        (star_1_2)    [below=of star_1_1]    {$*$};
                      \node[squarednode]      (S_star_1_2)       [below left=of star_1_2]   {$y_1$};
                      \node[squarednode]      (I_star_1_2)      [below=of star_1_2]   {$y_2$};

                      \node[roundnode_dashed]        (plus_2)     [below right=of system]        {$+$};
                      \node[roundnode]        (star_2_1)    [below=of plus_2]    {$*$};
                      \node[squarednode]      (a_2)      [below=of star_2_1]    {$a_2$};
                      \node[squarednode]      (I_star_2_1)      [below right=of star_2_1]   {$y_2$};

                      %Lines
                      \draw [->] (system.south) -- (plus_1.north);
                      \draw[->] (system.south) -- (plus_2.north);
                      \draw[->] (plus_1.south) -- (star_1_1.north);
                      \draw[->] (plus_2.south) -- (star_2_1.north);
                      \draw[->] (star_1_1.south) -- (a_1.north);
                      \draw[->] (star_1_1.south) -- (star_1_2.north);
                      \draw[->] (star_1_2.south) -- (S_star_1_2.north);
                      \draw[->] (star_1_2.south) -- (I_star_1_2.north);
                      \draw[->] (star_2_1.south) -- (a_2.north);
                      \draw[->] (star_2_1.south) -- (I_star_2_1.north);
                  \end{tikzpicture}
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.4\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      % Nodes
                      \node[roundnode]        (system)                            {$B$};

                      \node[roundnode]        (plus_1)     [below left=of system]        {$+$};
                      \node[roundnode]        (star_1_1)    [below=of plus_1]    {$*$};
                      \node[squarednode]      (a_3)      [below left=of star_1_1]    {$b_1$};
                      \node[roundnode]        (plus_1_2)    [below=of star_1_1]    {$+$};
                      \node[squarednode]      (I_plus_1_2)       [below left=of plus_1_2]   {$y_2$};
                      \node[squarednode]      (S_plus_1_2)      [below=of plus_1_2]   {$y_1$};

                      \node[roundnode_dashed]        (plus_2)     [below right=of system]        {$+$};
                      \node[roundnode]        (star_2_1)    [below=of plus_2]    {$*$};
                      \node[squarednode]      (a_4)      [below=of star_2_1]    {$b_2$};
                      \node[roundnode]        (sub_2_1)    [below right=of star_2_1]    {$-$};
                      \node[squarednode]      (S_sub_2_1)       [below left=of sub_2_1]   {$y_1$};
                      \node[squarednode]      (I_sub_2_1)      [below=of sub_2_1]   {$y_2$};

                      %Lines
                      \draw [->] (system.south) -- (plus_1.north);
                      \draw[->] (system.south) -- (plus_2.north);
                      \draw[->] (plus_1.south) -- (star_1_1.north);
                      \draw[->] (plus_2.south) -- (star_2_1.north);
                      \draw[->] (star_1_1.south) -- (a_3.north);
                      \draw[->] (star_1_1.south) -- (plus_1_2.north);
                      \draw[->] (plus_1_2.south) -- (I_plus_1_2.north);
                      \draw[->] (plus_1_2.south) -- (S_plus_1_2.north);
                      \draw[->] (star_2_1.south) -- (a_4.north);
                      \draw[->] (star_2_1.south) -- (sub_2_1.north);
                      \draw[->] (sub_2_1.south) -- (S_sub_2_1.north);
                      \draw[->] (sub_2_1.south) -- (I_sub_2_1.north);
                  \end{tikzpicture}
              \end{adjustbox}
          \end{center}

    \item Si se selecciona en A un nodo representante de un término en la ecuación i-ésima ecuación, se escoge un nodo representante de un término en la i-ésima ecuación en el sistema B:

          \begin{center}
              \begin{adjustbox}{width=0.4\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      % Nodes
                      \node[roundnode]        (system)                            {$A$};

                      \node[roundnode]        (plus_1)     [below left=of system]        {$+$};
                      \node[roundnode_dashed]        (star_1_1)    [below=of plus_1]    {$*$};
                      \node[squarednode]      (a_1)      [below left=of star_1_1]    {$a_1$};
                      \node[roundnode]        (star_1_2)    [below=of star_1_1]    {$*$};
                      \node[squarednode]      (S_star_1_2)       [below left=of star_1_2]   {$y_1$};
                      \node[squarednode]      (I_star_1_2)      [below=of star_1_2]   {$y_2$};

                      \node[roundnode]        (plus_2)     [below right=of system]        {$+$};
                      \node[roundnode]        (star_2_1)    [below=of plus_2]    {$*$};
                      \node[squarednode]      (a_2)      [below=of star_2_1]    {$a_2$};
                      \node[squarednode]      (I_star_2_1)      [below right=of star_2_1]   {$y_2$};

                      %Lines
                      \draw [->] (system.south) -- (plus_1.north);
                      \draw[->] (system.south) -- (plus_2.north);
                      \draw[->] (plus_1.south) -- (star_1_1.north);
                      \draw[->] (plus_2.south) -- (star_2_1.north);
                      \draw[->] (star_1_1.south) -- (a_1.north);
                      \draw[->] (star_1_1.south) -- (star_1_2.north);
                      \draw[->] (star_1_2.south) -- (S_star_1_2.north);
                      \draw[->] (star_1_2.south) -- (I_star_1_2.north);
                      \draw[->] (star_2_1.south) -- (a_2.north);
                      \draw[->] (star_2_1.south) -- (I_star_2_1.north);
                  \end{tikzpicture}
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.4\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      % Nodes
                      \node[roundnode]        (system)                            {$B$};

                      \node[roundnode]        (plus_1)     [below left=of system]        {$+$};
                      \node[roundnode_dashed]        (star_1_1)    [below=of plus_1]    {$*$};
                      \node[squarednode]      (a_3)      [below left=of star_1_1]    {$b_1$};
                      \node[roundnode]        (plus_1_2)    [below=of star_1_1]    {$+$};
                      \node[squarednode]      (I_plus_1_2)       [below left=of plus_1_2]   {$y_2$};
                      \node[squarednode]      (S_plus_1_2)      [below=of plus_1_2]   {$y_1$};

                      \node[roundnode]        (plus_2)     [below right=of system]        {$+$};
                      \node[roundnode]        (star_2_1)    [below=of plus_2]    {$*$};
                      \node[squarednode]      (a_4)      [below=of star_2_1]    {$b_2$};
                      \node[roundnode]        (sub_2_1)    [below right=of star_2_1]    {$-$};
                      \node[squarednode]      (S_sub_2_1)       [below left=of sub_2_1]   {$y_1$};
                      \node[squarednode]      (I_sub_2_1)      [below=of sub_2_1]   {$y_2$};

                      %Lines
                      \draw [->] (system.south) -- (plus_1.north);
                      \draw[->] (system.south) -- (plus_2.north);
                      \draw[->] (plus_1.south) -- (star_1_1.north);
                      \draw[->] (plus_2.south) -- (star_2_1.north);
                      \draw[->] (star_1_1.south) -- (a_3.north);
                      \draw[->] (star_1_1.south) -- (plus_1_2.north);
                      \draw[->] (plus_1_2.south) -- (I_plus_1_2.north);
                      \draw[->] (plus_1_2.south) -- (S_plus_1_2.north);
                      \draw[->] (star_2_1.south) -- (a_4.north);
                      \draw[->] (star_2_1.south) -- (sub_2_1.north);
                      \draw[->] (sub_2_1.south) -- (S_sub_2_1.north);
                      \draw[->] (sub_2_1.south) -- (I_sub_2_1.north);
                  \end{tikzpicture}
              \end{adjustbox}
          \end{center}


    \item Si el nodo seleccionado en A es el representante de una operación o una variable perteneciente a la i-ésima ecuación, se selecciona un nodo representante de una operación o una variable que pertenezca a algún término en la i-ésima ecuación en el sistema B:


          \begin{center}
              \begin{adjustbox}{width=0.4\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          squarednode_dashed/.style={rectangle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      % Nodes
                      \node[roundnode]        (system)                            {$A$};

                      \node[roundnode]        (plus_1)     [below left=of system]        {$+$};
                      \node[roundnode]        (star_1_1)    [below=of plus_1]    {$*$};
                      \node[squarednode]      (a_1)      [below left=of star_1_1]    {$a_1$};
                      \node[roundnode]        (star_1_2)    [below=of star_1_1]    {$*$};
                      \node[squarednode]      (S_star_1_2)       [below left=of star_1_2]   {$y_1$};
                      \node[squarednode]      (I_star_1_2)      [below=of star_1_2]   {$y_2$};

                      \node[roundnode]        (plus_2)     [below right=of system]        {$+$};
                      \node[roundnode]        (star_2_1)    [below=of plus_2]    {$*$};
                      \node[squarednode]      (a_2)      [below=of star_2_1]    {$a_2$};
                      \node[squarednode_dashed]      (I_star_2_1)      [below right=of star_2_1]   {$y_2$};

                      %Lines
                      \draw [->] (system.south) -- (plus_1.north);
                      \draw[->] (system.south) -- (plus_2.north);
                      \draw[->] (plus_1.south) -- (star_1_1.north);
                      \draw[->] (plus_2.south) -- (star_2_1.north);
                      \draw[->] (star_1_1.south) -- (a_1.north);
                      \draw[->] (star_1_1.south) -- (star_1_2.north);
                      \draw[->] (star_1_2.south) -- (S_star_1_2.north);
                      \draw[->] (star_1_2.south) -- (I_star_1_2.north);
                      \draw[->] (star_2_1.south) -- (a_2.north);
                      \draw[->] (star_2_1.south) -- (I_star_2_1.north);
                  \end{tikzpicture}
              \end{adjustbox}
              \qquad
              \begin{adjustbox}{width=0.4\textwidth, keepaspectratio}
                  \begin{tikzpicture}[
                          roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                          squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                          roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
                      ]
                      % Nodes
                      \node[roundnode]        (system)                            {$B$};

                      \node[roundnode]        (plus_1)     [below left=of system]        {$+$};
                      \node[roundnode]        (star_1_1)    [below=of plus_1]    {$*$};
                      \node[squarednode]      (a_3)      [below left=of star_1_1]    {$b_1$};
                      \node[roundnode]        (plus_1_2)    [below=of star_1_1]    {$+$};
                      \node[squarednode]      (I_plus_1_2)       [below left=of plus_1_2]   {$y_2$};
                      \node[squarednode]      (S_plus_1_2)      [below=of plus_1_2]   {$y_1$};

                      \node[roundnode]        (plus_2)     [below right=of system]        {$+$};
                      \node[roundnode]        (star_2_1)    [below=of plus_2]    {$*$};
                      \node[squarednode]      (a_4)      [below=of star_2_1]    {$b_2$};
                      \node[roundnode_dashed]        (sub_2_1)    [below right=of star_2_1]    {$-$};
                      \node[squarednode]      (S_sub_2_1)       [below left=of sub_2_1]   {$y_1$};
                      \node[squarednode]      (I_sub_2_1)      [below=of sub_2_1]   {$y_2$};

                      %Lines
                      \draw [->] (system.south) -- (plus_1.north);
                      \draw[->] (system.south) -- (plus_2.north);
                      \draw[->] (plus_1.south) -- (star_1_1.north);
                      \draw[->] (plus_2.south) -- (star_2_1.north);
                      \draw[->] (star_1_1.south) -- (a_3.north);
                      \draw[->] (star_1_1.south) -- (plus_1_2.north);
                      \draw[->] (plus_1_2.south) -- (I_plus_1_2.north);
                      \draw[->] (plus_1_2.south) -- (S_plus_1_2.north);
                      \draw[->] (star_2_1.south) -- (a_4.north);
                      \draw[->] (star_2_1.south) -- (sub_2_1.north);
                      \draw[->] (sub_2_1.south) -- (S_sub_2_1.north);
                      \draw[->] (sub_2_1.south) -- (I_sub_2_1.north);
                  \end{tikzpicture}
              \end{adjustbox}
          \end{center}

\end{itemize}

Luego de escoger los dos nodos, se remplaza el subárbol del nodo seleccionado en A por el subárbol del nodo seleccionado en B.

Por ejemplo si se tiene el sistema

\begin{align*}
    S' & = - a_1 * S * I         \\
    I' & = a_2 * S * I - a_3 * I \\
    R' & = a_4 * I,
\end{align*}

que se representa con el árbol computacional:

\begin{center}
    \begin{adjustbox}{width=0.5\textwidth, keepaspectratio}
        \begin{tikzpicture}[
                roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
            ]
            % Nodes
            \node[roundnode]        (system)                            {$A$};

            \node[roundnode]        (plus_S)     [below left=of system]        {$+$};
            \node[roundnode]        (star_S_1)    [below left=of plus_S]    {$*$};
            \node[squarednode]      (alpha_star_S_1)      [below left=of star_S_1]    {$a_1$};
            \node[roundnode]        (neg_star_S_1)    [below=of star_S_1]    {$-$};
            \node[roundnode]        (star_S_2)    [below=of neg_star_S_1]    {$*$};
            \node[squarednode]      (S_star_S)       [below left=of star_S_2]   {$S$};
            \node[squarednode]      (I_star_S)      [below=of star_S_2]   {$I$};

            \node[roundnode_dashed]        (plus_I)     [below=of system]        {$+$};
            \node[roundnode]        (star_I_1)    [below left=1cm and 0.5cm of plus_I]    {$*$};
            \node[squarednode]      (alpha_star_I_1)      [below left=1cm and 0.5cm of star_I_1]    {$a_2$};
            \node[roundnode]        (star_I_2)    [below=of star_I_1]    {$*$};
            \node[squarednode]      (S_star_I)       [below left=1cm and 0.5cm of star_I_2]   {$S$};
            \node[squarednode]      (I_star_I_1)      [below=of star_I_2]   {$I$};

            \node[roundnode]        (star_I_3)    [below right=1cm and 0.5cm of plus_I]    {$*$};
            \node[squarednode]      (beta_star_I_1)      [below=of star_I_3]    {$a_3$};
            \node[roundnode]        (neg_star_I_1)    [below right=1cm and 0.5cm of star_I_3]    {$-$};
            \node[squarednode]      (I_star_I_2)      [below=of neg_star_I_1]   {$I$};

            \node[roundnode]        (plus_R)     [below right=of system]        {$+$};
            \node[roundnode]        (star_R_1)    [below right=of plus_R]    {$*$};
            \node[squarednode]      (beta_star_R_1)      [below=of star_R_1]    {$a_4$};
            \node[squarednode]      (I_star_R)      [below right=of star_R_1]   {$I$};

            %Lines
            \draw [->] (system.south) -- (plus_S.north);
            \draw[->] (system.south) -- (plus_I.north);
            \draw[->] (system.south) -- (plus_R.north);

            \draw[->] (plus_S.south) -- (star_S_1.north);
            \draw[->] (star_S_1.south) -- (alpha_star_S_1.north);
            \draw[->] (star_S_1.south) -- (neg_star_S_1.north);
            \draw[->] (neg_star_S_1.south) -- (star_S_2.north);
            \draw[->] (star_S_2.south) -- (S_star_S.north);
            \draw[->] (star_S_2.south) -- (I_star_S.north);

            \draw[->] (plus_I.south) -- (star_I_1.north);
            \draw[->] (plus_I.south) -- (star_I_3.north);
            \draw[->] (star_I_1.south) -- (alpha_star_I_1.north);
            \draw[->] (star_I_1.south) -- (star_I_2.north);
            \draw[->] (star_I_2.south) -- (S_star_I.north);
            \draw[->] (star_I_2.south) -- (I_star_I_1.north);

            \draw[->] (star_I_3.south) -- (beta_star_I_1.north);
            \draw[->] (star_I_3.south) -- (neg_star_I_1.north);
            \draw[->] (neg_star_I_1.south) -- (I_star_I_2.north);

            \draw[->] (plus_R.south) -- (star_R_1.north);
            \draw[->] (star_R_1.south) -- (beta_star_R_1.north);
            \draw[->] (star_R_1.south) -- (I_star_R.north);
        \end{tikzpicture}
    \end{adjustbox}
\end{center}

y el sistema

\begin{align*}
    S' & = b_1 * (S + I) \\
    I' & = b_2 * S * I   \\
    R' & = b_3 * S,
\end{align*}

que visto en forma de árbol computacional es:

\begin{center}
    \begin{adjustbox}{width=0.5\textwidth, keepaspectratio}
        \begin{tikzpicture}[
                roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
            ]
            % Nodes
            \node[roundnode]        (system)                            {$B$};

            \node[roundnode]        (plus_S)     [below left=of system]        {$+$};
            \node[roundnode]        (star_S_1)    [below left=of plus_S]    {$*$};
            \node[squarednode]      (alpha_star_S_1)      [below left=of star_S_1]    {$b_1$};
            \node[roundnode]        (add_S_2)    [below=of star_S_1]    {$+$};
            \node[squarednode]      (S_star_S)       [below left=of add_S_2]   {$S$};
            \node[squarednode]      (I_star_S)      [below=of add_S_2]   {$I$};

            \node[roundnode_dashed]        (plus_I)     [below=of system]        {$+$};
            \node[roundnode]        (star_I_1)    [below=of plus_I]    {$*$};
            \node[squarednode]      (alpha_star_I_1)      [below left=of star_I_1]    {$b_2$};
            \node[roundnode]        (star_I_2)    [below right=of star_I_1]    {$*$};
            \node[squarednode]      (S_star_I)       [below left=of star_I_2]   {$S$};
            \node[squarednode]      (I_star_I_1)      [below=of star_I_2]   {$I$};

            \node[roundnode]        (plus_R)     [below right=of system]        {$+$};
            \node[roundnode]        (star_R_1)    [below right=of plus_R]    {$*$};
            \node[squarednode]      (beta_star_R_1)      [below=of star_R_1]    {$b_3$};
            \node[squarednode]      (S_star_R)      [below right=of star_R_1]   {$S$};

            %Lines
            \draw [->] (system.south) -- (plus_S.north);
            \draw[->] (system.south) -- (plus_I.north);
            \draw[->] (system.south) -- (plus_R.north);

            \draw[->] (plus_S.south) -- (star_S_1.north);
            \draw[->] (star_S_1.south) -- (alpha_star_S_1.north);
            \draw[->] (star_S_1.south) -- (add_S_2.north);
            \draw[->] (add_S_2.south) -- (S_star_S.north);
            \draw[->] (add_S_2.south) -- (I_star_S.north);

            \draw[->] (plus_I.south) -- (star_I_1.north);
            \draw[->] (star_I_1.south) -- (alpha_star_I_1.north);
            \draw[->] (star_I_1.south) -- (star_I_2.north);
            \draw[->] (star_I_2.south) -- (S_star_I.north);
            \draw[->] (star_I_2.south) -- (I_star_I_1.north);

            \draw[->] (plus_R.south) -- (star_R_1.north);
            \draw[->] (star_R_1.south) -- (beta_star_R_1.north);
            \draw[->] (star_R_1.south) -- (S_star_R.north);
        \end{tikzpicture}
    \end{adjustbox}
\end{center}

y como resultado de la operación de cruzamiento los nodos seleccionados son los resaltados con líneas discontinuas, entonces el sistema resultante sería

\begin{align*}
    S' & = - a_1 * S * I \\
    I' & = b_2 * S * I   \\
    R' & = a_4 * I,
\end{align*}

que se representa con el árbol computacional:

\begin{center}
    \begin{adjustbox}{width=0.5\textwidth, keepaspectratio}
        \begin{tikzpicture}[
                roundnode/.style={circle, draw, fill=gray!25, very thick, minimum size=7mm},
                squarednode/.style={rectangle, draw, fill=gray!25, very thick, minimum size=5mm},
                roundnode_dashed/.style={circle, draw, dashed, fill=gray!25, very thick, minimum size=7mm},
            ]
            % Nodes
            \node[roundnode]        (system)                            {$A$};

            \node[roundnode]        (plus_S)     [below left=of system]        {$+$};
            \node[roundnode]        (star_S_1)    [below left=of plus_S]    {$*$};
            \node[squarednode]      (alpha_star_S_1)      [below left=of star_S_1]    {$a_1$};
            \node[roundnode]        (neg_star_S_1)    [below=of star_S_1]    {$-$};
            \node[roundnode]        (star_S_2)    [below=of neg_star_S_1]    {$*$};
            \node[squarednode]      (S_star_S)       [below left=of star_S_2]   {$S$};
            \node[squarednode]      (I_star_S)      [below=of star_S_2]   {$I$};

            \node[roundnode_dashed]        (plus_I)     [below=of system]        {$+$};
            \node[roundnode]        (star_I_1)    [below=of plus_I]    {$*$};
            \node[squarednode]      (alpha_star_I_1)      [below left=of star_I_1]    {$b_2$};
            \node[roundnode]        (star_I_2)    [below right=of star_I_1]    {$*$};
            \node[squarednode]      (S_star_I)       [below left=of star_I_2]   {$S$};
            \node[squarednode]      (I_star_I_1)      [below=of star_I_2]   {$I$};

            \node[roundnode]        (plus_R)     [below right=of system]        {$+$};
            \node[roundnode]        (star_R_1)    [below right=of plus_R]    {$*$};
            \node[squarednode]      (beta_star_R_1)      [below=of star_R_1]    {$a_4$};
            \node[squarednode]      (I_star_R)      [below right=of star_R_1]   {$I$};

            %Lines
            \draw [->] (system.south) -- (plus_S.north);
            \draw[->] (system.south) -- (plus_I.north);
            \draw[->] (system.south) -- (plus_R.north);

            \draw[->] (plus_S.south) -- (star_S_1.north);
            \draw[->] (star_S_1.south) -- (alpha_star_S_1.north);
            \draw[->] (star_S_1.south) -- (neg_star_S_1.north);
            \draw[->] (neg_star_S_1.south) -- (star_S_2.north);
            \draw[->] (star_S_2.south) -- (S_star_S.north);
            \draw[->] (star_S_2.south) -- (I_star_S.north);

            \draw[->] (plus_I.south) -- (star_I_1.north);
            \draw[->] (star_I_1.south) -- (alpha_star_I_1.north);
            \draw[->] (star_I_1.south) -- (star_I_2.north);
            \draw[->] (star_I_2.south) -- (S_star_I.north);
            \draw[->] (star_I_2.south) -- (I_star_I_1.north);

            \draw[->] (plus_R.south) -- (star_R_1.north);
            \draw[->] (star_R_1.south) -- (beta_star_R_1.north);
            \draw[->] (star_R_1.south) -- (I_star_R.north);
        \end{tikzpicture}
    \end{adjustbox}
\end{center}

Con las operaciones de mutación y cruzamiento solo faltaría detallar la operación de selección para tener totalmente definido el algoritmo genético. Los detalles de esta última operación se presentan en la siguiente sección.

\section{Selección de las soluciones que pasan a la siguiente generación}\label{section:selection}

Dada una población inicial en una generación, se selecciona un subconjunto de individuos de esta y se mutan, y se toma otro subconjunto de individuos y se cruzan entre ellos. A partir de estas operaciones aparece un nuevo subconjunto de individuos que se agregan a la población inicial de la generación formando un nuevo conjunto de individuos el cual se define como población total de la generación.

De esta población total de la generación se seleccionan los individuos que mejor ajustan los datos. Se seleccionan también algunos individuos aleatorios con el fin de evitar mínimos locales en la búsqueda del mejor sistema. En total se seleccionan una cantidad igual a la presente en la población inicial.

Como resultado de esta selección se obtiene una nueva población que será la población de la siguiente generación. Estas operaciones de mutación y cruzamiento de la población inicial y luego selección de individuos se repiten múltiples veces con el fin de realizar varias generaciones intentando obtener mejores soluciones cada vez.

Una vez definida la forma de representar una solución como un árbol computacional, se plantean las operaciones de mutación y cruzamiento sobre estos árboles. Conociendo el costo de una solución se detalla un proceso de selección de individuos. Con estas operaciones se define un algoritmo genético y con este se puede realizar una regresión simbólica con el fin de obtener el sistema de ecuaciones diferenciales lineales con respecto a los parámetros que mejor ajuste un conjunto de datos.

En el siguiente capítulo se muestran los resultados obtenidos de aplicar la regresión simbólica planteada en varios conjuntos de puntos.